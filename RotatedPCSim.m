function [ReturnConditionA, ReturnConditionB] = RotatedPCSim(PCAInfo, Shift, NumResponses, FlashStrength, NoiseParameters, Verbose)%%   [ReturnConditionA, ReturnConditionB] = RotatedPCSim(PCAInfo, shift, NumResponses, FlashStrength, NoiseParameters, Verbose)%%	FlashStrength sets the flash strength used in simulating the responses.  If PoissonFlag is set to 0, then there are%	no Poisson fluctuations in the number of photons from trial to trial.  VarScaleFact is an arbitrary factor to scale%	the variance by x amount.  FlashTime allows for the time of the flash to be moved about.  NumResponses determines%	the number of simulated responses the function will generate.  Parameters for simulating the responses are take from%	Condition, CellParameters, and PCAProjections.%%	Created FMR%	Revised GDF: 5/25/02%		changed it to quickly generate noise if the flash strength = 0%		GDF: 10/20/02:  %			forced each single w/o noise to relax back to zero with and exponential time constant = 100ms%       GDF: 07/28/03%           complete optimization%		GDF:  02/04%			- changed the noise subtraction procedure%			- add the feature of allowing variability to be added to the mean response%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	Reset the state of the random number generator on each userand('state', sum(100*clock));%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Initialize several variablesReturnCondition.EpochNumbers = zeros(1,NumResponses);ReturnCondition.ExcludeEpochs = zeros(1,NumResponses);ReturnCondition.EpochData.Offset = zeros(1,NumResponses);ReturnCondition.UserInfo.StimulusStartTime = zeros(1,NumResponses);ReturnCondition.SearchCrit{1} = 'StimDur';%ReturnCondition.SearchCrit{2} =  'EpochPts';ReturnCondition.SearchCrit{3} = 'SampInterv';ReturnCondition.SearchPara(1) = 10;%ReturnCondition.SearchPara(2) = RespLength;ReturnCondition.SearchPara(3) = 1000;ReturnCondition.DecimatePts = 1;ReturnConditionA = ReturnCondition;ReturnConditionB = ReturnCondition;NumSinglesDim = length(PCAInfo.SinglesNoiseCov(1,:));PoissonFlag = NoiseParameters.PoissonFlag;RotatedPCs = PCAInfo.RotatedPCs(Shift);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Make A responses%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if Verbose    fprintf('Generating "A" responses \n')end% the mean and stdv of each component distributionASinglesCov = PCAInfo.SinglesNoiseCov .* NoiseParameters.SinglesVarScale;ASinglesMean = PCAInfo.MeanSingle;  % in time domain% The number of photons captured on each trialif PoissonFlag == 1    PhotonCounterA = poissrnd(FlashStrength, 1, NumResponses);endif PoissonFlag == 0    PhotonCounterA(1:NumResponses) = FlashStrength;end% this loop gets the number of trials where "x" number of photons were absorbed.% the variance and mean are scaled by x for this number of trials and samples% are taken using mvnrnd.  These sampled responses are temporalily stored and then% combined at the end. Each row in ComponentWeightsA is an simulated epoch.MaxPhotoIsomA = max(PhotonCounterA);if MaxPhotoIsomA ~= 0    for photons = 1:MaxPhotoIsomA		IsomIndex = length(find(PhotonCounterA == photons));		if IsomIndex ~= 0			TempAResps = mvnrnd(zeros(1,NumSinglesDim), ASinglesCov .* photons, IsomIndex);            TempAMeanTracker = repmat(ASinglesMean * photons, IsomIndex, 1);			if exist('ComponentWeightsA', 'var') ~= 1				ComponentWeightsA = TempAResps;                AMeanTracker = TempAMeanTracker;			else				ComponentWeightsA = [ComponentWeightsA; TempAResps];                AMeanTracker = [AMeanTracker; TempAMeanTracker];			end		end    end    ASimResps = ComponentWeightsA * PCAInfo.SinglesPCs';    ASimResps = ASimResps + AMeanTracker;end% make the responses where there were failuresAFailureNum = length(find(PhotonCounterA == 0));AFailureResps = zeros(AFailureNum,length(PCAInfo.MeanSingle));if FlashStrength == 0	ASimResps = zeros(NumResponses, length(PCAInfo.MeanSingle));elseif isempty(find(PhotonCounterA > 0))	ASimResps = AFailureResps;else	ASimResps = [ASimResps; AFailureResps];end%RandIndex = randperm(NumResponses);%ASimResp = ASimResps(RandIndex, :);% Add amplitude variance that peaks with the responseif NoiseParameters.AmpVar > 0    AmpVar = NoiseParameters.AmpVar;	ScalersA = normrnd(1,sqrt(AmpVar),NumResponses, 1);	ScalersA = repmat(ScalersA, 1, length(ASimResps(1,:)));	ASimResps = ASimResps .* ScalersA;endif Verbose    plot(((mean(ASimResps)).^2)./10, 'k')    hold on    plot(var(ASimResps), 'r')    title('mean squared and the variance of the "A" responses')    pause(0.1)    hold offend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Make B responses%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if Verbose    fprintf('Generating "B" responses \n')end% the mean and stdv of each component distributionBSinglesCov = PCAInfo.SinglesNoiseCov .* NoiseParameters.SinglesVarScale;BSinglesMean = RotatedPCs.MeanSingle;% The number of photons captured on each trialif PoissonFlag == 1    PhotonCounterB = poissrnd(FlashStrength, 1, NumResponses);endif PoissonFlag == 0    PhotonCounterB(1:NumResponses) = FlashStrength;end% see how A responses are simulated for explanationMaxPhotoIsomB = max(PhotonCounterB);if MaxPhotoIsomB ~= 0	for photons = 1:MaxPhotoIsomB		IsomIndex = length(find(PhotonCounterB == photons));		if IsomIndex ~= 0			TempBResps = mvnrnd(zeros(1,NumSinglesDim), BSinglesCov .* photons, IsomIndex);			TempBMeanTracker = repmat(BSinglesMean * photons, IsomIndex, 1);            if exist('ComponentWeightsB', 'var') ~= 1				ComponentWeightsB = TempBResps;                BMeanTracker = TempBMeanTracker;			else				ComponentWeightsB = [ComponentWeightsB; TempBResps];                BMeanTracker = [BMeanTracker; TempBMeanTracker];			end		end    end    BSimResps = ComponentWeightsB * RotatedPCs.PCs';    BSimResps = BSimResps + BMeanTracker;end	BFailureNum = length(find(PhotonCounterB == 0));BFailureResps = zeros(BFailureNum, length(PCAInfo.MeanSingle));if FlashStrength == 0	BSimResps = zeros(NumResponses, length(PCAInfo.MeanSingle));elseif isempty(find(PhotonCounterB > 0))	BSimResps = BFailureResps;else	BSimResps = [BSimResps; BFailureResps];end%RandIndex = randperm(NumResponses);%BSimResps = BSimResps(RandIndex, :);% Add amplitude variance that peaks with the responseif NoiseParameters.AmpVar > 0	ScalersB = normrnd(1,sqrt(AmpVar),NumResponses, 1);	ScalersB = repmat(ScalersB, 1, length(BSimResps(1,:)));	BSimResps = BSimResps .* ScalersB;endif Verbose    plot(((mean(BSimResps)).^2) ./ 10, 'k')    hold on    plot(var(BSimResps), 'r')    title('mean squared and the variance of the "B" responses')    pause(0.1)    hold offend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Compute Thermals %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%EigVec = PCAInfo.SinglesPCs;[NumDat, NumVec] = size(EigVec);ThermalProb = NoiseParameters.ThermalRate ./ 1000 .* (1800/2000);RodIntPts = PCAInfo.RodIntPts;NaturalTime = 2*RodIntPts;    % the time scale of the discriminationMeanThermalNumber = NumResponses * ThermalProb * NaturalTime;ThermalNumber = poissrnd(MeanThermalNumber,2,1);  % sample 2 numbers for A and B resps% Calculate the A Thermals as scene through theTotalTherms = sum(ThermalNumber);if Verbose    fprintf('Generating %d thermals \n', TotalTherms)endif TotalTherms > 0    % Make Thermals    Therms = RotatePCThermals(PCAInfo, TotalTherms, 1, 0, NoiseParameters, 0);    clear junk    % rotate thermals in time and calc the projs    TempData = Therms.EpochData.Data;    % Embed thermals in Zeroes    BaseLine = zeros(TotalTherms, NumDat);    TempData = [TempData, BaseLine];    % TempData is now 2x as long with zeros padding the end        % Generate the list of epochs where the thermals occur    RandList = ceil(NumResponses * rand(TotalTherms, 1));    RandTimes = ceil((NaturalTime-7) * rand(TotalTherms, 1));        % Rotate the thermals to occur at the random time given in RandTimes    for epoch = 1:TotalTherms        Rotated = RotateVector(RandTimes(epoch,:), TempData(epoch,:));        ThermalData(epoch,1:NumDat) = Rotated(1:NumDat);    end%	RandList    if ThermalNumber(1) > 0     % number of thermals in the A responses        ThermalDataA = ThermalData(1:ThermalNumber(1),:);        AList = RandList(1:ThermalNumber(1));    end    if ThermalNumber(2) > 0     % number of thermals in the B responses        ThermalDataB = ThermalData(ThermalNumber(1) + 1: TotalTherms,:);        BList = RandList(ThermalNumber(1) + 1:TotalTherms);    endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Generate continuous noise%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if Verbose    fprintf('Generating continuous noise \n')endNoiseSimA = GenerateContinuousNoise(NumResponses, PCAInfo, 0) .* NoiseParameters.ContNoiseScale;NoiseSimB = GenerateContinuousNoise(NumResponses, PCAInfo, 0) .* NoiseParameters.ContNoiseScale;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Add continuous noise to the A and B responsesASimResps = ASimResps + NoiseSimA; BSimResps = BSimResps + NoiseSimB;% Add Thermals to the A and B Responsesif ThermalNumber(1) > 0    ASimResps(AList,:) = ThermalDataA + ASimResps(AList,:);endif ThermalNumber(2) > 0    BSimResps(BList,:) = ThermalDataB + BSimResps(BList,:);endReturnConditionA.EpochData.Data = ASimResps;ReturnConditionB.EpochData.Data = BSimResps;% this step takes a surprising amount of time, so it has been commented out%ReturnConditionA = AverageAndVariance([], ReturnConditionA);%ReturnConditionB = AverageAndVariance([], ReturnConditionB);ReturnConditionA.UserInfo.PointShift = PCAInfo.TimeShifts(Shift);