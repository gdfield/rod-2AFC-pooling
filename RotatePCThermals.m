function ReturnCondition = RotatePCThermals(PCAInfo, NumResponses, FlashStrength, PoissonFlag, NoiseParameters, Verbose)%%   RotatePCThermals(Condition, PCAProjections, NumResponses, FlashStrength, PoissonFlag,...%                                     NoiseParameters, Verbose)%%	Created FMR: ?%	FlashStrength sets the flash strength used in simulating the responses.  If PoissonFlag is set to 0, then there are%	no Poisson fluctuations in the number of photons from trial to trial.  VarScaleFact is an arbitrary factor to scale%	the variance by x amount.  FlashTime allows for the time of the flash to be moved about.  NumResponses determines%	the number of simulated responses the function will generate.  Parameters for simulating the responses are take from%	Condition, CellParameters, and PCAProjections.%%	Created FMR%	Revised GDF: 5/25/02%		changed it to quickly generate noise if the flash strength = 0%		GDF: 10/20/02:  %			forced each single w/o noise to relax back to zero with and exponential time constant = 100ms%       GDF: 07/28/03%           complete optimization%       GDF: 08/24/03%           modified from the simulating singles program to simulate%           thermals without continuous noise.%       GDF 2005-06-21 simplified the script and removed lots of commented%       out code.%   % Initialize several variablesReturnCondition.EpochNumbers(1:NumResponses) = 0;ReturnCondition.ExcludeEpochs(1:NumResponses) = 0;ReturnCondition.EpochData.Offset(1:NumResponses) = 0;ReturnCondition.UserInfo.StimulusStartTime(1:NumResponses) = 0;ReturnCondition.SearchCrit{1} = 'StimDur';%ReturnCondition.SearchCrit{2} =  'EpochPts';ReturnCondition.SearchCrit{3} = 'SampInterv';ReturnCondition.SearchPara(1) = 10;%ReturnCondition.SearchPara(2) = RespLength;ReturnCondition.SearchPara(3) = 1000;ReturnCondition.DecimatePts = 1;NumSinglesDim = length(PCAInfo.SinglesNoiseCov(1,:));%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Make thermal responses%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the mean and stdv of each component distributionSinglesCov = PCAInfo.SinglesNoiseCov .* NoiseParameters.SinglesVarScale;SinglesMean = PCAInfo.MeanSingle;% The number of photons captured on each trialif PoissonFlag == 1    PhotonCounter = poissrnd(FlashStrength, 1, NumResponses);endif PoissonFlag == 0    PhotonCounter(1:NumResponses) = FlashStrength;end% this loop gets the number of trials where "x" number of photons were absorbed.% the variance and mean are scaled by x for this number of trials and samples% are taken using mvnrnd.  These sampled responses are temporalily stored and then% combined at the end. Each row in ComponentWeightsA is an simulated epoch.MaxPhotoIsom = max(PhotonCounter);for photons = 1:MaxPhotoIsom	IsomIndex = length(find(PhotonCounter == photons));	if IsomIndex ~= 0		TempResps = mvnrnd(zeros(1,NumSinglesDim), SinglesCov .* photons, IsomIndex);        TempMeanTracker = repmat(SinglesMean * photons, IsomIndex, 1);		if photons == 1			ComponentWeights = TempResps;            MeanTracker = TempMeanTracker;		else			ComponentWeights = [ComponentWeights; TempResps];            MeanTracker = [MeanTracker; TempMeanTracker];		end	endendSimResps = ComponentWeights * PCAInfo.SinglesPCs';SimResps = SimResps + MeanTracker;% Add amplitude variance that peaks with the responseif NoiseParameters.AmpVar > 0    AmpVar = NoiseParameters.AmpVar;	Scalers = normrnd(1,AmpVar,NumResponses, 1);	Scalers = repmat(Scalers, 1, length(SimResps(1,:)));	SimResps = SimResps .* Scalers;endif Verbose    plot(((mean(SimResps)).^2)./10, 'k')    hold on    plot(var(SimResps), 'r')    title('thermals')    pause(1)    hold offendReturnCondition.EpochData.Data = SimResps;